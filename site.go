package rez

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"net/http"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/ClickerMonkey/deps"
	"github.com/ClickerMonkey/rez/api"
	"github.com/go-chi/chi/v5"
)

type Site struct {
	Open      *api.Builder
	Scope     *deps.Scope
	ServeJSON bool
	ServeXML  bool

	injectTypes   map[reflect.Type]injectType
	errorHandler  ErrorHandler
	router        chi.Router
	url           string
	baseOperation api.Operation
	openJsonPath  string
}

var _ Router = &Site{}

func New(router chi.Router) *Site {
	site := &Site{
		Open:      api.NewBuilder(),
		Scope:     deps.Global(),
		ServeJSON: true,
		ServeXML:  false,

		injectTypes: make(map[reflect.Type]injectType),
		router:      router,
	}

	site.Open.Document.OpenAPI = "3.0.0"
	site.Open.Document.Info.Title = "REST (easy)"
	site.Open.Document.Info.Version = "0.0.0"
	site.Open.Document.Info.Description = "Documentation generated by github.com/ClickerMonkey/rez"

	return site
}

func (site Site) copy() *Site {
	copy := site
	copy.baseOperation = api.Operation{}.Merge(site.baseOperation)
	return &copy
}

// The internal chi.Router
func (site Site) Chi() chi.Router {
	return site.router
}

// The url of the router at this point.
func (site Site) URL() string {
	return site.url
}

// Sets the error handler at this router and all sub routers created after this is set.
func (site *Site) SetErrorHandler(handler ErrorHandler) {
	site.errorHandler = handler
}

// Handles the given error if its a HandledError, is handled by the error handler, or is handled with default behavior.
func (site *Site) HandleError(err error, response http.ResponseWriter, request *http.Request, scope *deps.Scope) {
	if handled, ok := err.(HandledError); ok {
		handled.Handle(response, request, scope)
		return
	}
	if site.errorHandler != nil {
		if site.errorHandler(err, response, request, scope) {
			return
		}
	}
	status := 500
	if hasStatus, ok := any(err).(HasStatus); ok {
		status = hasStatus.HTTPStatus()
	}
	http.Error(response, err.Error(), status)
}

// Adds the values/types of the given injection type.
func (site *Site) addInjectTypes(it injectType, valuesOrTypes []any) {
	for _, valueOrType := range valuesOrTypes {
		typ := api.GetType(valueOrType)
		if _, exists := site.injectTypes[typ]; exists {
			panic(fmt.Sprintf("%v already defined as an injectable type", typ))
		} else {
			site.injectTypes[typ] = it
		}
	}
}

// Adds the types of the given values as injectable request bodies. This avoids
// the necessity of rez.Body or rez.Request. If any of the values/types
// have already been defined this will cause a panic.
func (site *Site) DefineBody(bodies ...any) {
	site.addInjectTypes(injectTypeBody, bodies)
}

// Adds the types of the given values as injectable parameters. This avoids
// the necessity of rez.Param or rez.Request. If any of the values/types
// have already been defined this will cause a panic.
func (site *Site) DefineParam(bodies ...any) {
	site.addInjectTypes(injectTypeParam, bodies)
}

// Adds the types of the given values as injectable query parameters. This avoids
// the necessity of rez.Query or rez.Request. If any of the values/types
// have already been defined this will cause a panic.
func (site *Site) DefineQuery(bodies ...any) {
	site.addInjectTypes(injectTypeQuery, bodies)
}

// Adds the types of the given values as injectable header values. This avoids
// the necessity of rez.Header. If any of the values/types
// have already been defined this will cause a panic.
func (site *Site) DefineHeader(bodies ...any) {
	site.addInjectTypes(injectTypeHeader, bodies)
}

// Gets the base operation which has all inherited tags and responses set at the current router.
func (site *Site) GetOperations() *api.Operation {
	return &site.baseOperation
}

// Sets the base operation. All sub routes will inherit the properties on the base operation.
func (site *Site) SetOperations(op api.Operation) {
	site.baseOperation = op
}

// Updates the base operation (merges in given properties into existing base operation).
// All sub routes will inherit the properties on the base operation.
func (site *Site) UpdateOperations(op api.Operation) {
	site.baseOperation = site.baseOperation.Merge(op)
}

// Gets the path defined at the given pattern, if any
func (site *Site) GetPath(pattern string) *api.Path {
	full := site.url + pattern
	return site.Open.GetPath(full)
}

// Gets the path define at the given pattern, creating it if need be.
func (site *Site) CreatePath(pattern string) *api.Path {
	full := site.url + pattern
	existing := site.Open.GetPath(full)
	if existing == nil {
		site.Open.AddPath(full, &api.Path{})
		existing = site.Open.GetPath(full)
	}
	return existing
}

// Gets the path defined at the given pattern, if any
func (site *Site) UpdatePath(pattern string, path api.Path) {
	existing := site.CreatePath(pattern)
	*existing = existing.Merge(path)
}

// Sets the tags for all child routes starting at this router
func (site *Site) SetTags(tags []string) {
	site.baseOperation.Tags = tags
}

// Adds the tags for all child routes starting at this router
func (site *Site) AddTags(tags []string) {
	site.baseOperation.Tags = append(site.baseOperation.Tags, tags...)
}

// Sets the tags for all child routes starting at this router
func (site *Site) SetResponses(responses api.Responses) {
	site.baseOperation.Responses = responses
}

// Adds responses for all child routes starting at this router.
func (site *Site) AddResponses(responses api.Responses) {
	site.baseOperation.Responses = api.MergeMap(site.baseOperation.Responses, responses)
}

// Adds responses for all child routes starting at this router.
func (site *Site) AddResponse(code string, response api.Response) {
	site.baseOperation.Responses = api.MergeMap(site.baseOperation.Responses, api.Responses{
		code: &response,
	})
}

// Use appends one or more middlewares onto the Router stack.
func (site *Site) Use(fns ...any) {
	middlewares := make([]func(http.Handler) http.Handler, len(fns))
	for i, fn := range fns {
		op := site.getOperation(fn)
		site.baseOperation = site.baseOperation.Merge(op)
		middlewares[i] = site.middleware(fn)
	}
	site.router.Use(middlewares...)
}

// Use appends one or more middlewares onto the Router stack.
func (site *Site) With(fns ...any) Router {
	c := site.copy()

	middlewares := make([]func(http.Handler) http.Handler, len(fns))
	for i, fn := range fns {
		op := site.getOperation(fn)
		c.baseOperation = c.baseOperation.Merge(op)
		middlewares[i] = c.middleware(fn)
	}

	c.router = c.router.With(middlewares...)
	return c
}

// Group adds a new inline-Router along the current routing
// path, with a fresh middleware stack for the inline-Router.
func (site *Site) Group(fn func(r Router)) Router {
	c := site.copy()
	c.router = site.router.Group(func(r chi.Router) {
		fn(c)
	})
	return c
}

// Route mounts a sub-Router along a `patternâ€œ string.
func (site *Site) Route(pattern string, fn func(r Router)) Router {
	c := site.copy()
	c.url = c.url + pattern
	c.router = site.router.Route(pattern, func(r chi.Router) {
		c.router = r
		fn(c)
	})
	return c
}

var hasStatusType = deps.TypeOf[HasStatus]()
var hasRequestTypesType = deps.TypeOf[HasRequestTypes]()
var errorType = deps.TypeOf[error]()

func (site *Site) getOperation(fn any) api.Operation {
	fnType := reflect.TypeOf(fn)
	if fnType.Kind() != reflect.Func {
		panic("Only functions can be passed to rez.Router")
	}

	full := api.GetOperation(fn)
	if full != nil {
		return *full
	}

	op := api.Operation{}

	for i := 0; i < fnType.NumIn(); i++ {
		argType := fnType.In(i)

		var bodyType, paramType, queryType, headerType reflect.Type

		if argType.Implements(hasRequestTypesType) {
			argInstance := reflect.New(argType).Elem().Interface()
			if has, ok := argInstance.(HasRequestTypes); ok {
				requestTypes := has.GetRequestTypes()
				bodyType = requestTypes.Body
				paramType = requestTypes.Param
				queryType = requestTypes.Query
				headerType = requestTypes.Header
			}
		}

		concreteType := getConcrete(argType)
		if injectType, ok := site.injectTypes[concreteType]; ok {
			switch injectType {
			case injectTypeBody:
				bodyType = concreteType
			case injectTypeQuery:
				queryType = concreteType
			case injectTypeParam:
				paramType = concreteType
			case injectTypeHeader:
				headerType = concreteType
			}
		}

		if bodyType != nil {
			bodySchema := site.Open.GetSchema(bodyType)
			if bodySchema != nil {
				if op.RequestBody == nil {
					op.RequestBody = &api.RequestBody{}
				}
				op.RequestBody.Required = true
				op.RequestBody.Description = api.GetDescription(bodyType)
				if site.ServeJSON {
					if op.RequestBody.Content == nil {
						op.RequestBody.Content = api.Contents{}
					}
					op.RequestBody.Content[api.ContentTypeJSON] = &api.MediaType{
						Schema:  bodySchema,
						Example: api.GetExample(bodyType),
					}
				}
				for contentType, content := range op.RequestBody.Content {
					if content.Examples == nil {
						content.Examples = api.GetExamples(bodyType, contentType)
					}
				}
			}
		}
		if paramType != nil {
			op.AddParameters(site.Open, api.ParameterInPath, paramType)
		}
		if queryType != nil {
			op.AddParameters(site.Open, api.ParameterInQuery, queryType)
		}
		if headerType != nil {
			op.AddParameters(site.Open, api.ParameterInHeader, headerType)
		}
	}

	for i := 0; i < fnType.NumOut(); i++ {
		out := getConcrete(fnType.Out(i))

		outSchema := site.Open.GetSchema(out)
		if outSchema == nil {
			continue
		}
		statuses := []int{}

		if out.Implements(hasStatusType) && out.Kind() != reflect.Interface {
			arg := reflect.New(out).Interface()
			if hasStatus, ok := arg.(HasStatus); ok {
				statuses = hasStatus.HTTPStatuses()
			}
		}
		if len(statuses) == 0 && out.Implements(errorType) {
			statuses = []int{500}
		}
		if len(statuses) == 0 {
			statuses = []int{200}
		}
		for _, status := range statuses {
			key := strconv.Itoa(status)
			if op.Responses == nil {
				op.Responses = api.Responses{}
			}
			existing := op.Responses[key]
			if existing == nil {
				existing = &api.Response{}
				op.Responses[key] = existing
			}
			if existing.Content == nil {
				existing.Content = api.Contents{}
			}
			if existing.Description == "" {
				existing.Description = api.GetDescription(out)
			}
			content := existing.Content[api.ContentTypeJSON]
			if content == nil {
				content = &api.MediaType{}
				existing.Content[api.ContentTypeJSON] = content
			}
			if content.Schema != nil {
				merged := content.Schema.Merge(*outSchema)
				content.Schema = &merged
			} else {
				content.Schema = outSchema
			}
		}
	}

	if op.Responses["200"] == nil {
		op.Responses["200"] = &api.Response{}
	}

	api.GetOperationUpdate(fn, &op)

	return op
}

func (site *Site) handle(fn any, op *api.Operation) http.HandlerFunc {
	fnType := reflect.TypeOf(fn)
	if fnType.Kind() != reflect.Func {
		panic("Only functions can be passed to rez.Router")
	}

	if op != nil {
		*op = op.Merge(site.getOperation(fn))
	}

	return func(response http.ResponseWriter, request *http.Request) {
		scope := site.GetScope(response, request)

		result, err := scope.Invoke(fn)
		if err == nil {
			err = result.Err()
		}

		if err != nil {
			site.HandleError(err, response, request, scope)
		} else {
			firstDefined := any(nil)
			for _, r := range result {
				if r != nil {
					firstDefined = r
					break
				}
			}
			if firstDefined != nil {
				status := 200
				if hasStatus, ok := firstDefined.(HasStatus); ok {
					status = hasStatus.HTTPStatus()
				}

				sendJson(response, status, firstDefined)
			} else {
				sendStatus(response, 200)
			}
		}
	}
}

type scopeKey struct {
	key string
}

var ScopeKey = scopeKey{"RezScope"}

// Gets or creates a scope for the given request if it doesn't exist yet.
func (site *Site) GetScope(response http.ResponseWriter, request *http.Request) *deps.Scope {
	scope, isScope := request.Context().Value(ScopeKey).(*deps.Scope)
	if !isScope {
		scope = site.Scope.Spawn()
		scope.Dynamic = site.dynamicRequestInjection
		ctx := context.WithValue(request.Context(), ScopeKey, scope)
		router := Router(site)

		deps.SetScoped(scope, request.WithContext(ctx))
		deps.SetScoped(scope, &response)
		deps.SetScoped(scope, &ctx)
		deps.SetScoped(scope, &router)
		deps.SetScoped(scope, scope)
	}
	return scope
}

// Given a type and scope, try to return an injection value.
func (site *Site) dynamicRequestInjection(typ reflect.Type, scope *deps.Scope) (any, error) {
	typ = getConcrete(typ)
	if injectType, ok := site.injectTypes[typ]; ok {
		request, _ := deps.GetScoped[http.Request](scope)
		val := reflect.New(typ).Interface()

		switch injectType {
		case injectTypeBody:
			return val, getBody(val, request)
		case injectTypeParam:
			return val, getParam(val, request)
		case injectTypeQuery:
			return val, getQuery(val, request)
		case injectTypeHeader:
			return val, getHeader(val, request)
		}
	}

	return nil, nil
}

// The function to forward middleware onto the next handler.
// To change the request or response refer to them in the injectable function
// arguments as a pointer and change the value.
type MiddlewareNext func()

// Creates middleware which invokes the dependency injectable function.
// The function has access to the request, response, scope, and any other
// injectable request values. The values applied to the scope here will
// be passed down to lower routes and can be injected in their functions.
// If the function has problems injecting arguments or returns any errors
// then the next handler in the stack will not be invoked and the error
// will be handled like any other error.
func (site *Site) middleware(fn any) Middleware {
	return func(h http.Handler) http.Handler {
		return http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {
			scope := site.GetScope(response, request)

			scope.Set(MiddlewareNext(func() {
				w, _ := deps.GetScoped[http.ResponseWriter](scope)
				r, _ := deps.GetScoped[http.Request](scope)

				h.ServeHTTP(*w, r)
			}))

			result, err := scope.Invoke(fn)
			if err == nil {
				err = result.Err()
			}

			if err != nil {
				site.HandleError(err, response, request, scope)
			}
		})
	}
}

func (site *Site) applyOperations(operations []api.Operation, targets []**api.Operation) {
	for _, target := range targets {
		if *target == nil {
			*target = &api.Operation{}
		}
		**target = api.Merge(**target, site.baseOperation, operations...)
	}
}

// Handle and HandleFunc adds routes for `pattern` that matches all HTTP methods.
func (site *Site) HandleFunc(pattern string, fn any, operations ...api.Operation) *api.Path {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{
		&path.Get, &path.Post, &path.Put, &path.Patch, &path.Delete,
		&path.Options, &path.Trace, &path.Head,
	})
	site.router.HandleFunc(pattern, site.handle(fn, nil)) // TODO
	return path
}

// Method and MethodFunc adds routes for `pattern` that matches
// the `method` HTTP method.
func (site *Site) MethodFunc(method string, pattern string, fn any, operations ...api.Operation) *api.Operation {
	path := site.CreatePath(pattern)
	target := []**api.Operation{nil}
	switch strings.ToLower(method) {
	case "get":
		target[0] = &path.Get
	case "post":
		target[0] = &path.Post
	case "put":
		target[0] = &path.Put
	case "patch":
		target[0] = &path.Patch
	case "delete":
		target[0] = &path.Delete
	case "options":
		target[0] = &path.Options
	case "trace":
		target[0] = &path.Trace
	case "head":
		target[0] = &path.Head
	}
	site.applyOperations(operations, target)
	site.router.MethodFunc(method, pattern, site.handle(fn, *target[0]))
	return *target[0]
}

func (site *Site) Connect(pattern string, fn any) {
	site.router.Connect(pattern, site.handle(fn, nil))
}

func (site *Site) Delete(pattern string, fn any, operations ...api.Operation) *api.Operation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Delete})
	site.router.Delete(pattern, site.handle(fn, path.Delete))
	return path.Delete
}

func (site *Site) Get(pattern string, fn any, operations ...api.Operation) *api.Operation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Get})
	site.router.Get(pattern, site.handle(fn, path.Get))
	return path.Get
}

func (site *Site) Head(pattern string, fn any, operations ...api.Operation) *api.Operation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Head})
	site.router.Head(pattern, site.handle(fn, path.Head))
	return path.Head
}

func (site *Site) Options(pattern string, fn any, operations ...api.Operation) *api.Operation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Options})
	site.router.Options(pattern, site.handle(fn, path.Options))
	return path.Options
}

func (site *Site) Patch(pattern string, fn any, operations ...api.Operation) *api.Operation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Patch})
	site.router.Patch(pattern, site.handle(fn, path.Patch))
	return path.Patch
}

func (site *Site) Post(pattern string, fn any, operations ...api.Operation) *api.Operation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Post})
	site.router.Post(pattern, site.handle(fn, path.Post))
	return path.Post
}

func (site *Site) Put(pattern string, fn any, operations ...api.Operation) *api.Operation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Put})
	site.router.Put(pattern, site.handle(fn, path.Put))
	return path.Put
}

func (site *Site) Trace(pattern string, fn any, operations ...api.Operation) *api.Operation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Trace})
	site.router.Trace(pattern, site.handle(fn, path.Trace))
	return path.Trace
}

func (site *Site) NotFound(fn any) {
	site.router.NotFound(site.handle(fn, nil))
}

func (site *Site) MethodNotAllowed(fn any) {
	site.router.MethodNotAllowed(site.handle(fn, nil))
}

func (site *Site) BuildDocument() *api.Document {
	built := site.Open.Build()
	return &built
}

func (site *Site) BuildJSON() []byte {
	json, _ := json.Marshal(site.BuildDocument())
	return json
}

func (site *Site) ServeOpenJSON(pattern string) {
	var builtJson []byte = nil
	site.openJsonPath = site.url + pattern

	site.router.Get(site.openJsonPath, func(response http.ResponseWriter, request *http.Request) {
		if builtJson == nil {
			builtJson = site.BuildJSON()
		}
		sendJsonBytes(response, 200, builtJson)
	})
}

func (site *Site) ensureServeOpenJSON(pattern string) {
	if site.openJsonPath == "" {
		replaceEnd := regexp.MustCompile(`[^/]+$`)
		jsonPattern := replaceEnd.ReplaceAllString(pattern, "openapi3.json")
		site.ServeOpenJSON(jsonPattern)
	}
}

func (site *Site) ServeSwaggerUI(pattern string, options map[string]any) {
	site.ensureServeOpenJSON(pattern)

	if options == nil {
		options = make(map[string]any)
	}
	options["url"] = site.openJsonPath
	options["dom_id"] = "#ui-wrapper-new"
	if _, exists := options["docExpansion"]; !exists {
		options["docExpansion"] = "list"
	}
	if _, exists := options["deepLinking"]; !exists {
		options["deepLinking"] = true
	}
	if _, exists := options["filter"]; !exists {
		options["filter"] = true
	}
	optionsJson, _ := json.Marshal(options)

	html := []byte(`
<!DOCTYPE html>
<html>
	<head>
			<title>Docs</title>
			<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swagger-ui-dist@3.17.0/swagger-ui.css">
	</head>
	<body>
			<div id="ui-wrapper-new" data-spec="{{spec}}">
					Loading....
			</div>
	</body>
	<script src="https://unpkg.com/swagger-ui-dist@3.23.1/swagger-ui-bundle.js"></script>
	<script>
			var swaggerUIOptions = ` + string(optionsJson) + `;
			if (!swaggerUIOptions.presets) {
				swaggerUIOptions.presets = [
					SwaggerUIBundle.presets.apis,
					SwaggerUIBundle.SwaggerUIStandalonePreset
				];
			}
			if (!swaggerUIOptions.plugins) {
				swaggerUIOptions.plugins = [
					SwaggerUIBundle.plugins.DownloadUrl
				];
			}
			var ui = SwaggerUIBundle(swaggerUIOptions)
			window.ui = ui
	</script>
</html>`)

	site.router.Get(pattern, func(w http.ResponseWriter, r *http.Request) {
		sendHtml(w, 200, html)
	})
}

func (site *Site) ServeRedoc(pattern string) {
	site.ensureServeOpenJSON(pattern)

	html := []byte(`
<!DOCTYPE html>
<html>
	<head>
		<title>ReDoc</title>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
		<style> body { margin: 0; padding: 0; } </style>
	</head>
	<body>
		<redoc spec-url='` + site.openJsonPath + `'></redoc>
		<script src="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js"> </script>
	</body>
</html>
	`)

	site.router.Get(pattern, func(w http.ResponseWriter, r *http.Request) {
		sendHtml(w, 200, html)
	})
}

func (site *Site) Listen(addr string) {
	http.ListenAndServe(addr, site.router)
}

func (site *Site) Run() {
	addr := ":80"

	flag.StringVar(&addr, "host", ":80", "The port & host to serve requests from.")
	flag.Parse()

	site.Listen(addr)
}

func sendJsonBytes(response http.ResponseWriter, status int, bytes []byte) error {
	response.Header().Set("Content-Type", "application/json")
	response.WriteHeader(status)
	_, err := response.Write(bytes)
	return err
}

func sendJson(response http.ResponseWriter, status int, data any) error {
	response.Header().Set("Content-Type", "application/json")
	response.WriteHeader(status)
	enc := json.NewEncoder(response)
	return enc.Encode(data)
}

func sendHtml(response http.ResponseWriter, status int, html []byte) error {
	response.Header().Set("Content-Type", "text/html")
	response.WriteHeader(status)
	_, err := response.Write(html)
	return err
}

func sendStatus(response http.ResponseWriter, status int) {
	response.WriteHeader(status)
	response.Write(nil)
}

type injectType int8

const (
	injectTypeBody injectType = iota
	injectTypeParam
	injectTypeQuery
	injectTypeHeader
)

func getConcrete(typ reflect.Type) reflect.Type {
	for typ.Kind() == reflect.Pointer {
		typ = typ.Elem()
	}
	return typ
}
