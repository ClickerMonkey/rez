package rez

import (
	"bytes"
	"context"
	"encoding"
	"encoding/json"
	"encoding/xml"
	"flag"
	"fmt"
	"net/http"
	"reflect"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/ClickerMonkey/deps"
	"github.com/ClickerMonkey/rez/api"
	"github.com/go-chi/chi/v5"
)

// The main router for rez. Can only be created with rez.New. All sub routers
// created are also a Site.
type Site struct {
	Open      *api.Builder
	Scope     *deps.Scope
	ServeJSON bool
	ServeXML  bool

	injectTypes       map[reflect.Type]injectType
	validationOptions map[reflect.Type]ValidationOptions
	validationEnabled bool
	errorHandler      ErrorHandler
	internalHandler   InternalErrorHandler
	router            chi.Router
	url               string
	baseOperation     api.Operation
	openJsonPath      string
}

var _ Router = &Site{}

// Creates a new site given the base chi.Router.
func New(router chi.Router) *Site {
	site := &Site{
		Open:      api.NewBuilder(),
		Scope:     deps.Global(),
		ServeJSON: true,
		ServeXML:  false,

		injectTypes:       make(map[reflect.Type]injectType),
		validationOptions: make(map[reflect.Type]ValidationOptions),
		router:            router,
	}

	site.Open.Document.OpenAPI = "3.0.0"
	site.Open.Document.Info.Title = "REST (easy)"
	site.Open.Document.Info.Version = "0.0.0"
	site.Open.Document.Info.Description = "Documentation generated by github.com/ClickerMonkey/rez"

	return site
}

// Copies the site and operation template.
func (site Site) copy() *Site {
	copy := site
	copy.baseOperation = api.Operation{}.Merge(site.baseOperation)
	return &copy
}

// The internal chi.Router
func (site Site) Chi() chi.Router {
	return site.router
}

// The url of the router at this point.
func (site Site) URL() string {
	return site.url
}

// Sets the error handler at this router and all sub routers created after this is set.
func (site *Site) SetErrorHandler(handler ErrorHandler) {
	site.errorHandler = handler
}

// Sets the handler for errors we received outside of responding to the client.
func (site *Site) SetInternalErrorHandler(handle InternalErrorHandler) {
	site.internalHandler = handle
}

// Handles the given error if its a HandledError, is handled by the error handler, or is handled with default behavior.
func (site *Site) HandleError(err error, response http.ResponseWriter, request *http.Request, scope *deps.Scope) error {
	if handled, ok := err.(HandledError); ok {
		return handled.Handle(response, request, scope)
	}
	if site.errorHandler != nil {
		if handled, err := site.errorHandler(err, response, request, scope); handled {
			return err
		}
	}

	return site.Send(err, response)
}

// Handles a recovered panic
func (site *Site) handlePanic(err any, response http.ResponseWriter, request *http.Request) {
	var asErr error
	if e, ok := err.(error); ok {
		asErr = e
	} else {
		asErr = fmt.Errorf("unexpected error: %v", err)
	}
	asErr = site.HandleError(asErr, response, request, nil)
	site.internalError(asErr)
}

// Returns the validation options specified for the given type.
func (site Site) ValidationOptions(typ reflect.Type) ValidationOptions {
	if !site.validationEnabled {
		return ValidationOptions{Skip: true}
	}
	return site.validationOptions[typ]
}

// Sets the validation options for the type or value's type.
func (site *Site) SetValidationOptions(valueOrType any, options ValidationOptions) {
	typ := api.GetType(valueOrType)
	site.validationOptions[typ] = options
}

// Enables or disables validation for all routes in this router or sub routers created after this is set.
// By default validation is not enabled.
func (site *Site) EnableValidation(enabled bool) {
	site.validationEnabled = enabled
}

// Adds the values/types of the given injection type.
func (site *Site) addInjectTypes(it injectType, valuesOrTypes []any) {
	for _, valueOrType := range valuesOrTypes {
		typ := api.GetType(valueOrType)
		if _, exists := site.injectTypes[typ]; exists {
			panic(fmt.Sprintf("%v already defined as an injectable type", typ))
		} else {
			site.injectTypes[typ] = it
		}
	}
}

// Adds the types of the given values as injectable request bodies. This avoids
// the necessity of rez.Body or rez.Request. If any of the values/types
// have already been defined this will cause a panic.
func (site *Site) DefineBody(bodies ...any) {
	site.addInjectTypes(injectTypeBody, bodies)
}

// Adds the types of the given values as injectable path parameters. This avoids
// the necessity of rez.Param or rez.Request. If any of the values/types
// have already been defined this will cause a panic.
func (site *Site) DefinePath(paths ...any) {
	site.addInjectTypes(injectTypePath, paths)
}

// Adds the types of the given values as injectable query parameters. This avoids
// the necessity of rez.Query or rez.Request. If any of the values/types
// have already been defined this will cause a panic.
func (site *Site) DefineQuery(bodies ...any) {
	site.addInjectTypes(injectTypeQuery, bodies)
}

// Adds the types of the given values as injectable header values. This avoids
// the necessity of rez.Header. If any of the values/types
// have already been defined this will cause a panic.
func (site *Site) DefineHeader(bodies ...any) {
	site.addInjectTypes(injectTypeHeader, bodies)
}

// Gets the base operation which has all inherited tags and responses set at the current router.
func (site *Site) GetOperations() *api.Operation {
	return &site.baseOperation
}

// Sets the base operation. All sub routes will inherit the properties on the base operation.
func (site *Site) SetOperations(op api.Operation) {
	site.baseOperation = op
}

// Updates the base operation (merges in given properties into existing base operation).
// All sub routes will inherit the properties on the base operation.
func (site *Site) UpdateOperations(op api.Operation) {
	site.baseOperation = site.baseOperation.Merge(op)
}

// Gets the path defined at the given pattern, if any
func (site *Site) GetPath(pattern string) *api.Path {
	full := site.url + pattern
	return site.Open.GetPath(full)
}

// Gets the path define at the given pattern, creating it if need be.
func (site *Site) CreatePath(pattern string) *api.Path {
	full := site.url + pattern
	existing := site.Open.GetPath(full)
	if existing == nil {
		site.Open.AddPath(full, &api.Path{})
		existing = site.Open.GetPath(full)
	}
	return existing
}

// Gets the path defined at the given pattern, if any
func (site *Site) UpdatePath(pattern string, path api.Path) {
	existing := site.CreatePath(pattern)
	*existing = existing.Merge(path)
}

// Sets the tags for all child routes starting at this router
func (site *Site) SetTags(tags []string) {
	site.baseOperation.Tags = tags
}

// Adds the tags for all child routes starting at this router
func (site *Site) AddTags(tags []string) {
	site.baseOperation.Tags = append(site.baseOperation.Tags, tags...)
}

// Sets the tags for all child routes starting at this router
func (site *Site) SetResponses(responses api.Responses) {
	site.baseOperation.Responses = responses
}

// Adds responses for all child routes starting at this router.
func (site *Site) AddResponses(responses api.Responses) {
	site.baseOperation.Responses = api.MergeMap(site.baseOperation.Responses, responses)
}

// Adds responses for all child routes starting at this router.
func (site *Site) AddResponse(code string, response api.Response) {
	site.baseOperation.Responses = api.MergeMap(site.baseOperation.Responses, api.Responses{
		code: &response,
	})
}

// Use appends one or more middlewares onto the Router stack.
func (site *Site) Use(fns ...any) {
	middlewares := make([]func(http.Handler) http.Handler, len(fns))
	for i, fn := range fns {
		op := site.getOperation(fn)
		site.baseOperation = site.baseOperation.Merge(op)
		middlewares[i] = site.middleware(fn)
	}
	site.router.Use(middlewares...)
}

// Use appends one or more middlewares onto the Router stack.
func (site *Site) With(fns ...any) Router {
	c := site.copy()

	middlewares := make([]func(http.Handler) http.Handler, len(fns))
	for i, fn := range fns {
		op := site.getOperation(fn)
		c.baseOperation = c.baseOperation.Merge(op)
		middlewares[i] = c.middleware(fn)
	}

	c.router = c.router.With(middlewares...)
	return c
}

// Group adds a new inline-Router along the current routing
// path, with a fresh middleware stack for the inline-Router.
func (site *Site) Group(fn func(r Router)) Router {
	c := site.copy()
	c.router = site.router.Group(func(r chi.Router) {
		c.router = r
		fn(c)
	})
	return c
}

// Route mounts a sub-Router along a `patternâ€œ string.
func (site *Site) Route(pattern string, fn func(r Router)) Router {
	c := site.copy()
	c.url = c.url + pattern
	c.router = site.router.Route(pattern, func(r chi.Router) {
		c.router = r
		fn(c)
	})
	return c
}

func (site *Site) getOperation(fn any) api.Operation {
	fnType := reflect.TypeOf(fn)
	if fnType.Kind() != reflect.Func {
		panic("Only functions can be passed to rez.Router")
	}

	full := api.GetOperation(fn)
	if full != nil {
		return *full
	}

	op := api.Operation{}

	for i := 0; i < fnType.NumIn(); i++ {
		site.addInputType(&op, fnType.In(i))
	}

	for i := 0; i < fnType.NumOut(); i++ {
		site.addOutputType(&op, fnType.Out(i))
	}

	api.GetOperationUpdate(fn, &op)

	return op
}

var injectableType = deps.TypeOf[Injectable]()

// Adds the type as an input type for the operation
func (site *Site) addInputType(op *api.Operation, inputType reflect.Type) bool {
	concrete, ptr := getConcretePointer(inputType)

	var bodyType, pathType, queryType, headerType reflect.Type

	if ptr.Implements(injectableType) {
		argInstance := reflect.New(concrete).Interface()
		if has, ok := argInstance.(Injectable); ok {
			requestTypes := has.APIRequestTypes()
			bodyType = requestTypes.Body
			pathType = requestTypes.Path
			queryType = requestTypes.Query
			headerType = requestTypes.Header
		}
	}

	if injectType, ok := site.injectTypes[concrete]; ok {
		switch injectType {
		case injectTypeBody:
			bodyType = concrete
		case injectTypeQuery:
			queryType = concrete
		case injectTypePath:
			pathType = concrete
		case injectTypeHeader:
			headerType = concrete
		}
	}

	handled := false

	if bodyType != nil {
		bodySchema := site.Open.GetSchema(bodyType)
		if bodySchema != nil {
			if op.RequestBody == nil {
				op.RequestBody = &api.RequestBody{}
			}
			op.RequestBody.Required = true
			op.RequestBody.Description = api.GetDescription(bodyType)
			if site.ServeJSON {
				if op.RequestBody.Content == nil {
					op.RequestBody.Content = api.Contents{}
				}
				op.RequestBody.Content[api.ContentTypeJSON] = &api.MediaType{
					Schema:  bodySchema,
					Example: api.GetExample(bodyType),
				}
			}
			for contentType, content := range op.RequestBody.Content {
				if content.Examples == nil {
					content.Examples = api.GetExamples(bodyType, contentType)
				}
			}
		}
		handled = true
	}
	if pathType != nil {
		op.AddParameters(site.Open, api.ParameterInPath, pathType)
		handled = true
	}
	if queryType != nil {
		op.AddParameters(site.Open, api.ParameterInQuery, queryType)
		handled = true
	}
	if headerType != nil {
		op.AddParameters(site.Open, api.ParameterInHeader, headerType)
		handled = true
	}

	return handled
}

var hasStatusType = deps.TypeOf[HasStatus]()
var errorType = deps.TypeOf[error]()

// Adds the type as a response type for the operation
func (site *Site) addOutputType(op *api.Operation, responseType reflect.Type) bool {
	out := getConcrete(responseType)

	outSchema := site.Open.GetSchema(out)
	if outSchema == nil {
		return false
	}
	statuses := []int{}

	if out.Implements(hasStatusType) && out.Kind() != reflect.Interface {
		arg := reflect.New(out).Interface()
		if hasStatus, ok := arg.(HasStatus); ok {
			statuses = hasStatus.HTTPStatuses()
		}
	}
	if len(statuses) == 0 && out.Implements(errorType) {
		statuses = []int{500}
	}
	if len(statuses) == 0 {
		statuses = []int{200}
	}
	for _, status := range statuses {
		key := strconv.Itoa(status)
		if op.Responses == nil {
			op.Responses = api.Responses{}
		}
		existing := op.Responses[key]
		if existing == nil {
			existing = &api.Response{}
			op.Responses[key] = existing
		}
		if existing.Content == nil {
			existing.Content = api.Contents{}
		}
		if existing.Description == "" {
			existing.Description = api.GetDescription(out)
		}
		content := existing.Content[api.ContentTypeJSON]
		if content == nil {
			content = &api.MediaType{}
			existing.Content[api.ContentTypeJSON] = content
		}
		if content.Schema != nil {
			merged := content.Schema.Merge(*outSchema)
			content.Schema = &merged
		} else {
			content.Schema = outSchema
		}
	}

	return true
}

// Creates a HandlerFunc for the given function and operation.
func (site *Site) handle(fn any, op *api.Operation) http.HandlerFunc {
	fnType := reflect.TypeOf(fn)
	if fnType.Kind() != reflect.Func {
		panic("Only functions can be passed to rez.Router")
	}

	if op != nil {
		*op = op.Merge(site.getOperation(fn))
	}

	return func(w http.ResponseWriter, request *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				site.handlePanic(err, w, request)
			}
		}()

		scope, freeScope := site.GetScope(w, request)

		scope.Set(op)

		result, err := scope.Invoke(fn)
		if err == nil {
			err = result.Err()
		}

		if err != nil {
			err := site.HandleError(err, w, request, scope)
			site.internalError(err)
		} else {
			returned := result.Defined()
			response := any(nil)
			if len(returned) > 0 {
				response = returned[0]
			}

			err := site.Send(response, w)
			site.internalError(err)
		}

		if freeScope {
			err = scope.Free()
			site.internalError(err)
		}
	}
}

// Sends the response to the writer.
func (site *Site) Send(response any, w http.ResponseWriter) error {
	if canSend, ok := response.(CanSend); ok {
		return canSend.HTTPSend(w)
	}

	status := http.StatusOK
	if _, isError := response.(error); isError {
		status = http.StatusInternalServerError
	}
	if hasStatus, ok := response.(HasStatus); ok {
		status = hasStatus.HTTPStatus()
	}

	if response == nil {
		w.WriteHeader(status)
		_, err := w.Write(nil)
		return err
	}

	contentType := string(api.ContentTypeJSON)
	if hasContentType, ok := response.(HasContentType); ok {
		contentType = hasContentType.HTTPContentType()
	}

	w.Header().Set("Content-Type", string(contentType))
	w.WriteHeader(status)

	var err error
	data := &bytes.Buffer{}

	switch {
	case strings.Contains(contentType, "xml"):
		enc := xml.NewEncoder(data)
		err = enc.Encode(response)
	case strings.Contains(contentType, "json"):
		enc := json.NewEncoder(data)
		err = enc.Encode(response)
	case strings.Contains(contentType, "text"):
		if marshaller, ok := response.(encoding.TextMarshaler); ok {
			text, err := marshaller.MarshalText()
			if err != nil {
				return err
			}
			data.Write(text)
		} else if bytes, ok := response.([]byte); ok {
			data.Write(bytes)
		} else {
			data.WriteString(toString(response))
		}
	}

	if err != nil {
		return err
	}

	if data.Len() > 0 {
		w.Header().Set("Content-Length", strconv.Itoa(data.Len()))

		_, err = w.Write(data.Bytes())
	} else {
		// Unsupported type. Implement HTTPSend for this response type.
		_, err = w.Write(nil)
	}

	return err
}

type scopeKey struct {
	key string
}

var ScopeKey = scopeKey{"RezScope"}

// Gets or creates a scope for the given request if it doesn't exist yet.
func (site *Site) GetScope(response http.ResponseWriter, request *http.Request) (requestScope *deps.Scope, freeScope bool) {
	scope, isScope := request.Context().Value(ScopeKey).(*deps.Scope)
	if !isScope {
		scope = site.Scope.Spawn()
		scope.Dynamic = site.dynamicRequestInjection
		ctx := context.WithValue(request.Context(), ScopeKey, scope)
		router := Router(site)
		validator := NewValidator(site, scope)

		deps.SetScoped(scope, request.WithContext(ctx))
		deps.SetScoped(scope, &response)
		deps.SetScoped(scope, &ctx)
		deps.SetScoped(scope, &router)
		deps.SetScoped(scope, scope)
		deps.SetScoped(scope, validator)

		freeScope = true
	}
	requestScope = scope

	return
}

// Given a type and scope, try to return an injection value.
func (site *Site) dynamicRequestInjection(typ reflect.Type, scope *deps.Scope) (any, error) {
	typ = getConcrete(typ)
	if injectType, ok := site.injectTypes[typ]; ok {
		val := reflect.New(typ).Interface()

		var inj Injectable

		switch injectType {
		case injectTypeBody:
			inj = &Body[any]{Value: val}
		case injectTypePath:
			inj = &Path[any]{Value: val}
		case injectTypeQuery:
			inj = &Query[any]{Value: val}
		case injectTypeHeader:
			inj = &Header[any]{Value: val}
		}

		err := inj.ProvideDynamic(scope)
		if err != nil {
			return nil, err
		}
		return val, nil
	}

	return nil, nil
}

// The function to forward middleware onto the next handler.
// To change the request or response refer to them in the injectable function
// arguments as a pointer and change the value.
type MiddlewareNext func()

// Creates a new MiddlewareNext given a handler and scope.
func NewMiddlewareNext(h http.Handler, scope *deps.Scope) MiddlewareNext {
	return func() {
		w, _ := deps.GetScoped[http.ResponseWriter](scope)
		r, _ := deps.GetScoped[http.Request](scope)

		h.ServeHTTP(*w, r)
	}
}

// Creates middleware which invokes the dependency injectable function.
// The function has access to the request, response, scope, and any other
// injectable request values. The values applied to the scope here will
// be passed down to lower routes and can be injected in their functions.
// If the function has problems injecting arguments or returns any errors
// then the next handler in the stack will not be invoked and the error
// will be handled like any other error.
func (site *Site) middleware(fn any) func(h http.Handler) http.Handler {
	return func(h http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, request *http.Request) {
			defer func() {
				if err := recover(); err != nil {
					site.handlePanic(err, w, request)
				}
			}()

			scope, freeScope := site.GetScope(w, request)

			scope.Set(NewMiddlewareNext(h, scope))

			result, err := scope.Invoke(fn)
			if err == nil {
				err = result.Err()
			}

			if err != nil {
				site.HandleError(err, w, request, scope)
			}
			if freeScope {
				site.internalError(scope.Free())
			}
		})
	}
}

func (site *Site) internalError(err error) {
	if err != nil && site.internalHandler != nil {
		site.internalHandler(err)
	}
}

func (site *Site) applyOperations(operations []api.Operation, targets []**api.Operation) {
	for _, target := range targets {
		if *target == nil {
			*target = &api.Operation{}
		}
		**target = api.Merge(**target, site.baseOperation, operations...)
	}
}

// Handle and HandleFunc adds routes for `pattern` that matches all HTTP methods.
func (site *Site) HandleFunc(pattern string, fn any, operations ...api.Operation) *api.Path {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{
		&path.Get, &path.Post, &path.Put, &path.Patch, &path.Delete,
		&path.Options, &path.Trace, &path.Head,
	})
	site.router.HandleFunc(pattern, site.handle(fn, nil)) // TODO
	return path
}

// Method and MethodFunc adds routes for `pattern` that matches
// the `method` HTTP method.
func (site *Site) MethodFunc(method string, pattern string, fn any, operations ...api.Operation) RouterOperation {
	path := site.CreatePath(pattern)
	target := []**api.Operation{nil}
	switch strings.ToLower(method) {
	case "get":
		target[0] = &path.Get
	case "post":
		target[0] = &path.Post
	case "put":
		target[0] = &path.Put
	case "patch":
		target[0] = &path.Patch
	case "delete":
		target[0] = &path.Delete
	case "options":
		target[0] = &path.Options
	case "trace":
		target[0] = &path.Trace
	case "head":
		target[0] = &path.Head
	}
	site.applyOperations(operations, target)
	site.router.MethodFunc(method, pattern, site.handle(fn, *target[0]))
	return SiteOperation{*target[0], site}
}

func (site *Site) Connect(pattern string, fn any) {
	site.router.Connect(pattern, site.handle(fn, nil))
}

func (site *Site) Delete(pattern string, fn any, operations ...api.Operation) RouterOperation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Delete})
	site.router.Delete(pattern, site.handle(fn, path.Delete))
	return SiteOperation{path.Delete, site}
}

func (site *Site) Get(pattern string, fn any, operations ...api.Operation) RouterOperation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Get})
	site.router.Get(pattern, site.handle(fn, path.Get))
	return SiteOperation{path.Get, site}
}

func (site *Site) Head(pattern string, fn any, operations ...api.Operation) RouterOperation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Head})
	site.router.Head(pattern, site.handle(fn, path.Head))
	return SiteOperation{path.Head, site}
}

func (site *Site) Options(pattern string, fn any, operations ...api.Operation) RouterOperation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Options})
	site.router.Options(pattern, site.handle(fn, path.Options))
	return SiteOperation{path.Options, site}
}

func (site *Site) Patch(pattern string, fn any, operations ...api.Operation) RouterOperation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Patch})
	site.router.Patch(pattern, site.handle(fn, path.Patch))
	return SiteOperation{path.Patch, site}
}

func (site *Site) Post(pattern string, fn any, operations ...api.Operation) RouterOperation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Post})
	site.router.Post(pattern, site.handle(fn, path.Post))
	return SiteOperation{path.Post, site}
}

func (site *Site) Put(pattern string, fn any, operations ...api.Operation) RouterOperation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Put})
	site.router.Put(pattern, site.handle(fn, path.Put))
	return SiteOperation{path.Put, site}
}

func (site *Site) Trace(pattern string, fn any, operations ...api.Operation) RouterOperation {
	path := site.CreatePath(pattern)
	site.applyOperations(operations, []**api.Operation{&path.Trace})
	site.router.Trace(pattern, site.handle(fn, path.Trace))
	return SiteOperation{path.Trace, site}
}

func (site *Site) NotFound(fn any) {
	site.router.NotFound(site.handle(fn, nil))
}

func (site *Site) MethodNotAllowed(fn any) {
	site.router.MethodNotAllowed(site.handle(fn, nil))
}

func (site *Site) BuildDocument() *api.Document {
	built := site.Open.Build()
	return &built
}

func (site *Site) BuildJSON() []byte {
	json, _ := json.Marshal(site.BuildDocument())
	return json
}

func (site *Site) ServeOpenJSON(pattern string) {
	var builtJson []byte = nil
	site.openJsonPath = site.url + pattern

	site.router.Get(site.openJsonPath, func(w http.ResponseWriter, request *http.Request) {
		if builtJson == nil {
			builtJson = site.BuildJSON()
		}
		site.SendAny(builtJson, w, 200, api.ContentTypeJSON)
	})
}

func (site *Site) ensureServeOpenJSON(pattern string) {
	if site.openJsonPath == "" {
		replaceEnd := regexp.MustCompile(`[^/]+$`)
		jsonPattern := replaceEnd.ReplaceAllString(pattern, "openapi3.json")

		site.ServeOpenJSON(jsonPattern)
	}
}

func (site *Site) ServeSwaggerUI(pattern string, options map[string]any) {
	site.ensureServeOpenJSON(pattern)

	if options == nil {
		options = make(map[string]any)
	}
	options["url"] = site.openJsonPath
	options["dom_id"] = "#ui-wrapper-new"
	if _, exists := options["docExpansion"]; !exists {
		options["docExpansion"] = "list"
	}
	if _, exists := options["deepLinking"]; !exists {
		options["deepLinking"] = true
	}
	if _, exists := options["filter"]; !exists {
		options["filter"] = true
	}
	optionsJson, _ := json.Marshal(options)

	html := []byte(`
<!DOCTYPE html>
<html>
	<head>
			<title>Docs</title>
			<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swagger-ui-dist@3.17.0/swagger-ui.css">
	</head>
	<body>
			<div id="ui-wrapper-new" data-spec="{{spec}}">
					Loading....
			</div>
	</body>
	<script src="https://unpkg.com/swagger-ui-dist@3.23.1/swagger-ui-bundle.js"></script>
	<script>
			var swaggerUIOptions = ` + string(optionsJson) + `;
			if (!swaggerUIOptions.presets) {
				swaggerUIOptions.presets = [
					SwaggerUIBundle.presets.apis,
					SwaggerUIBundle.SwaggerUIStandalonePreset
				];
			}
			if (!swaggerUIOptions.plugins) {
				swaggerUIOptions.plugins = [
					SwaggerUIBundle.plugins.DownloadUrl
				];
			}
			var ui = SwaggerUIBundle(swaggerUIOptions)
			window.ui = ui
	</script>
</html>`)

	site.router.Get(pattern, func(w http.ResponseWriter, r *http.Request) {
		site.SendAny(html, w, 200, api.ContentTypeHTML)
	})
}

func (site *Site) ServeRedoc(pattern string) {
	site.ensureServeOpenJSON(pattern)

	html := []byte(`
<!DOCTYPE html>
<html>
	<head>
		<title>ReDoc</title>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
		<style> body { margin: 0; padding: 0; } </style>
	</head>
	<body>
		<redoc spec-url='` + site.openJsonPath + `'></redoc>
		<script src="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js"> </script>
	</body>
</html>
	`)

	site.router.Get(pattern, func(w http.ResponseWriter, r *http.Request) {
		site.SendAny(html, w, 200, api.ContentTypeHTML)
	})
}

func (site *Site) Listen(addr string) {
	http.ListenAndServe(addr, site.router)
}

func (site *Site) Run() {
	addr := ":80"

	flag.StringVar(&addr, "host", ":80", "The port & host to serve requests from.")
	flag.Parse()

	site.Listen(addr)
}

func (site *Site) PrintPaths() {
	doc := site.BuildDocument()

	paths := make([][]string, 0)
	methodOrder := []string{
		"GET", "POST", "PUT", "DELETE",
		"PATCH", "HEAD", "OPTIONS", "TRACE",
	}
	methodMap := map[string]int{
		"GET":     8,
		"POST":    7,
		"PUT":     6,
		"DELETE":  5,
		"PATCH":   4,
		"HEAD":    3,
		"OPTIONS": 2,
		"TRACE":   1,
	}

	includeAbout := false

	for url, path := range doc.Paths {
		ops := []*api.Operation{
			path.Get, path.Post, path.Put, path.Delete,
			path.Patch, path.Head, path.Options, path.Trace,
		}
		for methodIndex, op := range ops {
			if op == nil {
				continue
			}

			about := op.Summary
			if about == "" {
				about = op.Description
			}
			if about != "" {
				includeAbout = true
			}

			paths = append(paths, []string{
				methodOrder[methodIndex],
				url,
				about,
			})
		}
	}

	sort.Slice(paths, func(i, j int) bool {
		a := paths[i]
		b := paths[j]

		if a[1] != b[1] {
			return a[1] < b[1]
		}

		return methodMap[b[0]] < methodMap[a[0]]
	})

	headers := []string{"Method", "URL"}
	if includeAbout {
		headers = append(headers, "About")
	}

	printGrid(headers, paths, gridOptions{
		padding:  1,
		space:    " ", // "\x20", // 32,
		newline:  "\n",
		tl:       "\u250C", // 218
		tr:       "\u2510", // 191,
		bl:       "\u2514", // 192,
		br:       "\u2518", // 217,
		h:        "\u2500", // 196,
		v:        "\u2502", // 179,
		c:        "\u253C", // 197,
		tdivider: "\u252C", // 194,
		ldivider: "\u251C", // 195,
		rdivider: "\u2524", // 180,
		bdivider: "\u2534", // 193,
	})
}

type gridOptions struct {
	padding  int
	tl       string
	tr       string
	bl       string
	br       string
	h        string
	v        string
	c        string
	tdivider string
	ldivider string
	rdivider string
	bdivider string
	space    string
	newline  string
}

func printGrid(headers []string, grid [][]string, options gridOptions) {
	columns := len(headers)
	empty := make([]string, columns)
	max := make([]int, columns)
	for c := 0; c < columns; c++ {
		max[c] = len(headers[c])
	}
	for _, row := range grid {
		for c := 0; c < columns; c++ {
			if len(row[c]) > max[c] {
				max[c] = len(row[c])
			}
		}
	}
	rowWidth := (columns + 1) + columns*options.padding
	for c := 0; c < columns; c++ {
		rowWidth += max[c]
	}
	cap := rowWidth * (1 + len(grid)*2)

	sb := strings.Builder{}
	sb.Grow(cap)

	printLines := func(l string, values []string, padding string, d string, r string) {
		if len(l) > 0 {
			sb.WriteString(l)
		}
		for c := 0; c < columns; c++ {
			if c > 0 && len(d) > 0 {
				sb.WriteString(d)
			}
			if padding != "" {
				sb.WriteString(values[c])
				sb.WriteString(strings.Repeat(string(padding), max[c]-len(values[c])+options.padding))
			}
		}
		if len(r) > 0 {
			sb.WriteString(r)
		}
		sb.WriteString(options.newline)
	}

	printLines(options.tl, empty, options.h, options.tdivider, options.tr)
	printLines(options.v, headers, options.space, options.v, options.v)
	for _, row := range grid {
		printLines(options.ldivider, empty, options.h, options.c, options.rdivider)
		printLines(options.v, row, options.space, options.v, options.v)
	}
	printLines(options.bl, empty, options.h, options.bdivider, options.br)

	fmt.Print(sb.String())
}

func (site *Site) SendAny(response []byte, w http.ResponseWriter, status int, contentType api.ContentType) {
	if contentType != api.ContentTypeNone {
		w.Header().Set("Content-Type", string(contentType))
	}
	w.Header().Set("Content-Length", strconv.Itoa(len(response)))
	w.WriteHeader(status)
	_, err := w.Write(response)
	site.internalError(err)
}

type injectType int8

const (
	injectTypeBody injectType = iota
	injectTypePath
	injectTypeQuery
	injectTypeHeader
)

func reflectType(x any) reflect.Type {
	if t, ok := x.(reflect.Type); ok {
		return t
	}
	if v, ok := x.(reflect.Value); ok {
		return v.Type()
	}
	return reflect.TypeOf(x)
}

func getConcrete(typ reflect.Type) reflect.Type {
	for typ.Kind() == reflect.Pointer {
		typ = typ.Elem()
	}
	return typ
}

func getConcretePointer(typ reflect.Type) (reflect.Type, reflect.Type) {
	c := getConcrete(typ)
	return c, reflect.PointerTo(c)
}

// An operation for a site.
type SiteOperation struct {
	operation *api.Operation
	site      *Site
}

var _ RouterOperation = SiteOperation{}

func (op SiteOperation) Router() Router {
	return op.site
}

func (op SiteOperation) Operation() *api.Operation {
	return op.operation
}

func (op SiteOperation) Input(input ...any) {
	for _, t := range input {
		op.site.addInputType(op.operation, reflectType(t))
	}
}

func (op SiteOperation) Output(output ...any) {
	for _, t := range output {
		op.site.addOutputType(op.operation, reflectType(t))
	}
}
